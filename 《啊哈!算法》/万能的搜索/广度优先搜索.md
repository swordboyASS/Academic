#### :star: 1.广搜解迷宫----代码好像有点问题
```c++

思路： 函数解决杀敌数+广搜解决能否到达某个点问题
问题： cin.gelin()函数的使用


#include <iostream>
using namespace std;

struct note
{
	int x; //横坐标
	int y; //纵坐标
	int f; //路径
	int s; //步数 
}; 

int main()
{
	struct note que[2501]; //题目要求不超过50*50
	int a[51][51] = {0},book[51][51]={0};// 地图、标记数组 
	
	int next[4][2] ={{0,1},{1,0},{0,-1},{-1,0}}; //方向数组,右下上左 
	int head,tail; 
	int i,j,k,n,m,startx,starty,tx,ty,q,p,flag;
	
	cin>>n>>m;  //输入地图长宽，
	for(i=1;i<=n;i++)
	{ 
		for(j=1;j<=m;j++)
		{cin>>a[i][j];} 
	}		
	
	cin>>startx>>starty>>p>>q;  //输入起始点、终点
	
	
	//队列初始化
	head=1;
	tail=1;
	que[tail].x=startx;
	que[tail].y=starty;
	que[tail].f=0;
	que[tail].s=0;
	tail++; 
	book[startx][starty]=1;
	
	flag= 0; //用于标志是否到达目的点
	while(head<tail) //当队列不为空是循环
	{
		//枚举4个方向
		for(k=0;k<=3;k++)
		{
			//计算下一个点坐标
			tx=que[head].x+next[k][0];
			ty=que[head].y+next[k][1];	
			
			//判断是否越界
			if(tx<1 || tx>n || ty<1 || ty>m)
				continue; 
			
			//判断是否为障碍物，或者已经在路径中
			if(a[tx][ty]==0 || book[tx][ty]==0)
			{
				book[tx][ty]=1; //标记为走过
				que[tail].x=tx;
				que[tail].y=ty;
				que[tail].f=head; //因为这个点是从heda扩展出来的，所以它的父亲是head。
				que[tail].s=que[head].s+1;
				tail++;	
			}
			
			if(tx==p && ty==q)
			{
				flag=1;
				break;
			 } 
		 } 
		 
		 if(flag==1)
		 	break;
		head++;
		
	 } 
	
	cout<<que[tail-1].s; //tail指向了下一个位置，并不是当前位置，所以要减一 
	//没有考虑不可达的情况 
	
	 
	return 0;
} 
```


#### :star: 2.再解炸弹人---广搜
```c++
#include <iostream>
#include <stdio.h>
using namespace std;

struct note
{
	int x; //横坐标 
	int y; //纵坐标 
};
char a[20][21]; //用于存储地图，不会超过20*20 

int getnum(int i,int j)
{
	int sum,x,y;
	sum=0; //总敌人数
	//将坐标i，j复制到2个新变量x,y中，以便于统计上下左右4个方向可消灭的敌人
	
	//向上统计 
	x=i,y=j;
	while(a[x][y]!='#')	//判断的点是不是墙，如果不是就统计
	{
		if(a[x][y]=='G')
			sum++;
		x--; //向上走 
	 }
	 //向下统计 
	x=i,y=j;
	while(a[x][y]!='#')
	{
		if(a[x][y]=='G')
			sum++;
		x++;	
	  }
	//向左统计
	x=i,y=j;
	while(a[x][y]!='#')
	{
		if(a[x][y]=='G')
			sum++;
		y--;	
	}
	//向右统计
	x=i,y=j;
	while(a[x][y]!='#')
	{
		if(a[x][y]=='G')
			sum++;
		y++;	
	}
	
	return sum;
 } 

int main()
{
	struct note que[401]; //不超过20*20
	int head,tail;
	int book[20][20]={0}; //标记数组
	int i,j,k,sum,max=0,mx,my,n,m,startx,starty,tx,ty;
	
	//定义一个用于表示走的方向数组
	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};	//右下左上 
	cin>>n>>m>>startx>>starty;
	 
	for(i=0;i<n;i++)
	{
//		cin.getline(a[i],20); //按行读入 
		scanf("%s",&a[i]);
	}
	
	head=1;
	tail=1;
	que[tail].x=startx;
	que[tail].y=starty;
	tail++;
	book[startx][starty]=1;
	max=getnum(startx,starty);	//得到初始位置的最大杀敌数 
	
	mx=startx;
	my=starty; 
	
	while(head<tail)
	{
		//枚举4个方向
		for(k=0;k<4;k++)
		{
			
			tx=que[head].x+next[k][0];
			ty=que[head].y+next[k][1];
			
			//是否越界
			if(tx<0 || tx>n-1 || ty<0 || ty>m-1)
				continue;
			
			//判断是否为平地或者已经走过
			if(a[tx][ty]=='.' && book[tx][ty]==0)
			{
				book[tx][ty]=1;	//标记为走过
				que[tail].x=tx;
				que[tail].y=ty;
				tail++;
				
				//统计当前新扩展的点可消灭的敌人数
				sum=getnum(tx,ty);
				//更新max
				if(sum>max)
				{
					max=sum; //mx.my用于记录该点坐标
					mx=tx;
					my=ty; 
					
				 } 
			 } 
		 } 
		 head++;
		 
	 } 
	
	cout<<"将炸弹放在("<<mx<<","<<my<<")处,可最多消灭敌人"<<max<<"个"; 
	return 0;
 } 
```
