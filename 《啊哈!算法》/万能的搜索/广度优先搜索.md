#### :star: 1.广搜解迷宫----代码好像有点问题
```c++
#include <iostream>
using namespace std;

struct note
{
	int x; //横坐标
	int y; //纵坐标
	int f; //路径
	int s; //步数 
}; 

int main()
{
	struct note que[2501]; //题目要求不超过50*50
	int a[51][51] = {0},book[51][51]={0};// 地图、标记数组 
	
	int next[4][2] ={{0,1},{1,0},{0,-1},{-1,0}}; //方向数组,右下上左 
	int head,tail; 
	int i,j,k,n,m,startx,starty,tx,ty,q,p,flag;
	
	cin>>n>>m;  //输入地图长宽，
	for(i=1;i<=n;i++)
	{ 
		for(j=1;j<=m;j++)
		{cin>>a[i][j];} 
	}		
	
	cin>>startx>>starty>>p>>q;  //输入起始点、终点
	
	
	//队列初始化
	head=1;
	tail=1;
	que[tail].x=startx;
	que[tail].y=starty;
	que[tail].f=0;
	que[tail].s=0;
	tail++; 
	book[startx][starty]=1;
	
	flag= 0; //用于标志是否到达目的点
	while(head<tail) //当队列不为空是循环
	{
		//枚举4个方向
		for(k=0;k<=3;k++)
		{
			//计算下一个点坐标
			tx=que[head].x+next[k][0];
			ty=que[head].y+next[k][1];	
			
			//判断是否越界
			if(tx<1 || tx>n || ty<1 || ty>m)
				continue; 
			
			//判断是否为障碍物，或者已经在路径中
			if(a[tx][ty]==0 || book[tx][ty]==0)
			{
				book[tx][ty]=1; //标记为走过
				que[tail].x=tx;
				que[tail].y=ty;
				que[tail].f=head; //因为这个点是从heda扩展出来的，所以它的父亲是head。
				que[tail].s=que[head].s+1;
				tail++;	
			}
			
			if(tx==p && ty==q)
			{
				flag=1;
				break;
			 } 
		 } 
		 
		 if(flag==1)
		 	break;
		head++;
		
	 } 
	
	cout<<que[tail-1].s; //tail指向了下一个位置，并不是当前位置，所以要减一 
	//没有考虑不可达的情况 
	
	 
	return 0;
} 
```


#### :satr: 2.再解炸弹人---广搜
```c++

```
