#### :satr: 1.最小生成树--kruscal算法,配合图的连通性使用
```c++
#include <iostream>
using namespace std;

typedef struct edge
{
	int u;
	int v;
	int w;	
}EDGE;
EDGE e[10]; //要比边的条数大1
int n,m;
int f[7]={0},sum=0,count=0; //f容量比顶点数大1

void quicksort(int left ,int right)
{
	int i,j;
	EDGE t;
	if(left>=right) return ;
	i=left;
	j=right;
	while(i!=j)
	{
		//从右边先开始 
		while(e[j].w>=e[left].w && i<j) j--;
		while(e[i].w<=e[left].w && i<j) i++;
		if(i<j)
		{
			t=e[i];
			e[i]=e[j];
			e[j]=t;
		}	
	}
	t=e[left];
	e[left]=e[i];
	e[i]=t;
	
	quicksort(left,i-1);
	quicksort(i+1,right);	
} 
//递归函数，最重要的部分，不停的找爹，直到找到祖宗为止，即犯罪团伙的最高领导人。
//“擒贼先擒王原则”
int getf(int v)
{
	if(f[v]==v)
		return v;
	else{
		//路径压缩，每次在函数返回的时候，顺带把路上遇到的人的boss改为最后找到的祖宗编号，这样可以 提高今后找到犯罪团伙
		//的最高领导人(树的祖先)的速度
		f[v]=getf(f[v]);
		return f[v];
	}
 }

//合并两子集何的函数
int merge(int v,int u)
{
	int t1,t2;  //t1,t2分别是v,u的boss
	t1=getf(v);
	t2=getf(u);
	if(t1!=t2)  //判断2个节点是否在同一个集合中,即是否为同一个祖先
	{
		f[t2]=t1;
		return 1;//不连通 
		//靠左原则，左边变成右边的boss。即把右边的集合，作为左边集合的子集合
		//经过路径压缩后，将f[u]的根的值也赋值为v的祖先f[t1]
	}
	return 0; //连通 
 }

int main()
{
	int i;
	cin>>n>>m;

	for(i=1;i<=n;i++)
	{
		f[i]=i;
	} 
	for(i=1;i<=m;i++)
	{
		
		cin>>e[i].u>>e[i].v>>e[i].w;
		
	 }
	quicksort(1,m); //通过权值进行快排 
	//kruskal算法核心部分
	for(i=1;i<=m;i++)//从小到大枚举每一条边 
	{
		if(merge(e[i].u,e[i].v))
		{
			count++;
			sum += e[i].w;
		}
		if(count==n-1) break;//边选完了 
	 } 
	 cout<<sum; 
	return 0;
}

```
