#### :star: 1.回旋矩阵(蛇形填数)
```c++
#include <stdio.h>
#include <string.h>
#define manx 20
int a[manx][manx];
int main()
{
	int n,x,y;
	scanf("%d",&n);
	memset(a,0,sizeof(a));
	int tot=a[x=0][y=n-1]=1;
	while(tot<n*n)
	{
		while(x+1<n && !a[x+1][y]) a[++x][y] = ++tot; //向下走，x+1<n防止超越边界，!a[x+1][y]当这个位置还没有被填充， 
													//为0的时候，这里也体现了&&的短路特点，导致a[x+1][y] 不会产生数组越界问题。
		while(y>0 && !a[x][y-1]) a[x][--y]	= ++tot;
		while(x>0 && !a[x-1][y]) a[--x][y] = ++tot;
		while(y+1<n && !a[x][y+1]) a[x][++y] = ++tot;
	}
	for(x=0;x<n;x++)
	{	for(y=0;y<n;y++)
		{
			printf("%3d",a[x][y]);
	
		}
		printf("\n");
	}
	return 0;
}
```

#### :star: 2.竖式问题，找出3位乘以2位数，让其结果的所有数字都在输入的数字集合中，包括中间待加数字。
```c++
#include <stdio.h>
#include <string.h>
int main ()
{
	int count=0;// 记录满足条件的个数 
	char s[20],buf[99];
	scanf("%s",s); //不需要&符号 
	for(int abc=111;abc<=999;abc++)
	 for(int de=11;de<=99;de++)
	 {
	 	int x=abc*(de%10),y=abc*(de/10),z=abc*de;
	 	sprintf(buf,"%d%d%d%d%d",abc,de,x,y,z); // 注意buf字符串的长度，应该足够长 
	 	int ok=1;
	 	for(int i=0;i<strlen(buf);i++) // strlen()获得字符串有效的实际长度，如"abcd" 长度为4，返回结束标志'\0'之前的长度
	 	 if(strchr(s,buf[i])==NULL) ok=0;
	 	if(ok)
	 	{
	 		printf("<%d>\n",++count);
	 		printf("%5d\nX%4d\n-----\n%5d\n%4d\n-----\n%5d\n\n",abc,de,x,y,z);
		 }
	 }
	 printf("The number of solutions = %d\n",count);
	return 0;
 } 
 
 
 TeX中的引号问题
 #include <stdio.h>
int main ()
{
//	scanf("%s")在遇到空白字符和TAB是会停下来
//	gerchar(),从标准输入中读取一个字符,如没有字符可读则返回一个EOF(int型) 
//	putchar() //输出一个字符。
	int c,q=1;
	while((c=getchar()) != EOF)
	{
		if(c=='"') {printf("%s",q?"``":"''"); q=!q;}
		else printf("%c",c);
	}
	return 0;
 } 
```

#### :star: 3.镜像回文词,镜像是指左右镜像。
```c++
#include <stdio.h>
#include <string.h>
#include <ctype.h>
const	char* rev="A   3  HIL JM O   2TUVWXY51SE Z  8 ";  //镜像的对应关系,必须要有空格才能一一对应。 
const	char* msg[]={"not a palindrome","a regular palindrome","a mirrored string","a mirrored palindrome"}; 
char r(char ch)
{
	if(isalpha(ch)) return rev[ch-'A'];//判断是否为字母 ，isdigit(),isprint(),都在ctype.h中定义，toupper（），tolower()
	return rev[ch-'0'+25];//越过前面26个字母，数组以0为起始点，所以减25； 
}
int main ()
{
	char s[30];
	while(scanf("%s",s)==1)//表示还有输入
	{
		int len=strlen(s);
		int p=1,m=1;
		for(int i=0;i<(len+1)/2;i++){ //+1的原因是防止只有1个字符的情况，/2是只需要判断到正中间数之前的部分 
			if(s[i] != s[len-1-i]) p=0;//不是回文数。
			if(r(s[i]) != s[len-1-i]) m=0; //不是镜像串 
		} 
		printf("%s -- is %s.\n\n",s,msg[m*2+p]);//m=0,p=0 ==0;m=1,p=0 ==2; m=0,p=1 ==1; m=1 p=1 ==3;
	 } 
	return 0;
 } 
```

#### :star: 4.猜数字游戏的提示
```c++
#include <stdio.h>
#define maxn 1010
int main ()
{
	int n,a[maxn],b[maxn];
	int kase=0;
	while(scanf("%d",&n)==1 && n){ //n=0是输入结束
		printf("Game %d:\n" ,++kase);
		for(int i=0;i<n;i++) scanf("%d",&a[i]);
		for(;;){
		 int A=0,B=0;
		 for(int i=0;i<n;i++)
		 {
		 	scanf("%d",&b[i]);
		 	if(a[i]==b[i]) A++;
		 }//得出A的值 
		 if(b[0]==0) break; //正常序列保证了没有0，故只需要判断第一个即可。 
		 for(int d=1;d<=9;d++)
		 {
		 	int c1=0,c2=0; //统计数字d在答案序列和猜测序列各出现多少次。
			 for(int i=0;i<n;i++)
			 {
			 	if(a[i] == d) c1++;
			 	if(b[i] == d) c2++;
			  } 
			  if(c1<c2)  B += c1;else B += c2;
		  } 
		 printf("	(%d,%d)\n",A,B-A); //输出结果(a,b) 正确的位置数就是a, 为了求b，对于每个数字1~9,统计二者
		 							//出现的次数c1和c2,则min(c1,c2)就是该数字对b的贡献。最后要减去a。 
		} 
	}
	return 0;
 } 
```
